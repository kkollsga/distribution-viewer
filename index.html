<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Probability Distribution Charter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body { font-family: 'Inter', sans-serif; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 lg:p-6">
        <header class="mb-6">
            <h1 class="text-3xl font-bold text-center text-indigo-700">Probability Distribution Visualizer</h1>
        </header>

        <div class="bg-white p-4 sm:p-6 rounded-xl shadow-xl mb-6 h-[500px] md:h-[600px] relative">
            <canvas id="distributionsChart"></canvas>
        </div>

        <div class="mb-6 flex flex-wrap items-center justify-between gap-4 p-4 bg-white rounded-xl shadow-lg">
            <div class="flex items-center">
                <input type="checkbox" id="logScaleX" class="h-5 w-5 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer">
                <label for="logScaleX" class="ml-2 text-sm font-medium text-gray-700 cursor-pointer">Logarithmic X-Axis</label>
            </div>
            <div class="flex items-center">
                <label for="plotPoints" class="mr-2 text-sm font-medium text-gray-700">Plot Points:</label>
                <input type="number" id="plotPoints" value="300" min="50" max="2000" step="50" class="mt-1 block w-24 py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
            </div>
        </div>

        <div id="distributionsList" class="mb-6 space-y-3">
            <!-- Distribution items will be added here dynamically -->
        </div>
        
        <!-- Collapsible form -->
        <div id="addEditFormContainer" class="mb-6 overflow-hidden transition-all duration-500 max-h-0 opacity-0">
            <div class="p-6 bg-white rounded-xl shadow-xl space-y-5 border-2 border-indigo-100">
                <h2 id="formTitle" class="text-xl font-semibold text-indigo-700 flex items-center">
                    <i class="fas fa-chart-line mr-2"></i>
                    <span>Add New Distribution</span>
                </h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-end">
                    <div>
                        <label for="distName" class="block text-xs font-medium text-gray-600">Distribution Name (Optional)</label>
                        <input type="text" id="distName" placeholder="e.g., Baseline Case" 
                            class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition-colors duration-200 ease-in-out hover:border-indigo-400">
                    </div>
                    <div>
                        <label for="distType" class="block text-xs font-medium text-gray-600">Distribution Type</label>
                        <select id="distType" 
                            class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition-colors duration-200 ease-in-out hover:border-indigo-400">
                            <!-- Options added dynamically -->
                        </select>
                    </div>
                </div>

                <div>
                    <label class="block text-xs font-medium text-gray-600 mb-1">Parameters</label>
                    <div id="paramInputsContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-x-4 gap-y-3 items-end bg-gray-50 p-4 rounded-md border border-gray-200">
                        <!-- Parameter inputs added dynamically -->
                    </div>
                </div>
                
                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 items-end">
                    <div>
                        <label class="block text-xs font-medium text-gray-600">Range Clipping (Optional)</label>
                        <div class="flex items-center mt-1">
                            <input type="number" id="clipMin" placeholder="Min" 
                                class="block w-full py-2 px-3 border border-gray-300 bg-white rounded-l-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition-colors duration-200 ease-in-out hover:border-indigo-400" step="any">
                            <span class="inline-flex items-center px-2 h-[38px] border-t border-b border-gray-300 bg-gray-100 text-gray-500 text-sm">-</span>
                            <input type="number" id="clipMax" placeholder="Max" 
                                class="block w-full py-2 px-3 border border-l-0 border-gray-300 bg-white rounded-r-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition-colors duration-200 ease-in-out hover:border-indigo-400" step="any">
                        </div>
                    </div>

                    <div>
                        <label for="distColor" class="block text-xs font-medium text-gray-600">Color</label>
                        <select id="distColor" 
                            class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition-colors duration-200 ease-in-out hover:border-indigo-400">
                            <!-- Color options added dynamically -->
                        </select>
                    </div>

                    <div class="flex items-center pt-5 sm:pt-6 justify-start">
                        <input type="checkbox" id="fillLine" class="h-5 w-5 text-indigo-600 rounded cursor-pointer">
                        <label for="fillLine" class="ml-2 text-sm font-medium text-gray-700 cursor-pointer">Fill Under Line</label>
                    </div>
                </div>

                <div class="flex items-center justify-end space-x-3 pt-3">
                    <button id="cancelEditButton" title="Cancel Edit" 
                        class="hidden inline-flex items-center justify-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md shadow-sm text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200">
                        <i class="fas fa-times mr-2"></i> Cancel
                    </button>
                    <button id="saveDistButton" title="Add Distribution" 
                        class="inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-all duration-200 hover:shadow-md">
                        <i class="fas fa-plus mr-2"></i> Add
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Toggle button for adding new distribution -->
        <div class="flex justify-center mb-8">
            <button id="toggleFormButton" class="group relative flex items-center justify-center gap-2 px-6 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-medium rounded-lg shadow-lg hover:shadow-xl transform transition-all duration-300 hover:scale-105 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                <span id="toggleButtonText">Add New Distribution</span>
                <i id="toggleButtonIcon" class="fas fa-plus-circle text-lg transition-transform duration-300"></i>
            </button>
        </div>

    <script>
        // --- Configuration ---
        const COLOR_MAP = {
            'Crimson': '#FF6384', 'Sky Blue': '#36A2EB', 'Gold': '#FFCE56',
            'Teal': '#4BC0C0', 'Lavender': '#9966FF', 'Orange': '#FF9F40',
            'Emerald': '#2ECC71', 'Ruby': '#E74C3C', 'Sunflower': '#F1C40F',
            'Amethyst': '#8E44AD'
        };
        let chartInstance = null;
        let distributions = []; 
        let currentEditIndex = -1; 
        const FLOAT_COMPARISON_TOLERANCE = 1e-9;
        let isFormVisible = false;

        // --- Distribution Definitions ---
        const distributionDefinitions = {
            uniform: {
                name: 'Uniform',
                params: [
                    { id: 'a', label: 'Min (a):', default: 0, type: 'number', step: 'any' },
                    { id: 'b', label: 'Max (b):', default: 10, type: 'number', step: 'any' }
                ],
                discrete: false,
                pdf: (x, p) => (p.b <= p.a ? 0 : (x >= p.a && x <= p.b ? 1 / (p.b - p.a) : 0)),
                cdf: (x, p) => {
                    if (p.b <= p.a) return (x < p.a ? 0 : 1); // Or handle as error
                    if (x < p.a) return 0;
                    if (x >= p.b) return 1;
                    return (x - p.a) / (p.b - p.a);
                },
                range: (p) => ({ min: p.a, max: p.b }),
                support: (p) => ({min: p.a, max: p.b})
            },
            normal: {
                name: 'Normal',
                params: [
                    { id: 'mu', label: 'Mean (μ):', default: 0, type: 'number', step: 'any' },
                    { id: 'sigma', label: 'Std Dev (σ):', default: 1, type: 'number', step: 'any', minVal: 0.00001 }
                ],
                discrete: false,
                pdf: (x, p) => (p.sigma <= 0 ? 0 : (1 / (p.sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * Math.pow((x - p.mu) / p.sigma, 2))),
                cdf: (x, p) => {
                    if (p.sigma <= 0) return (x < p.mu ? 0 : 1);
                    return 0.5 * (1 + math.erf((x - p.mu) / (p.sigma * Math.sqrt(2))));
                },
                range: (p) => (p.sigma > 0 ? { min: p.mu - 4 * p.sigma, max: p.mu + 4 * p.sigma } : {min: p.mu -1, max: p.mu+1}),
                support: () => ({min: -Infinity, max: Infinity})
            },
            lognormal: {
                name: 'Lognormal',
                params: [
                    { id: 'muLog', label: 'Log Mean (μ of log):', default: 0, type: 'number', step: 'any' },
                    { id: 'sigmaLog', label: 'Log Std Dev (σ of log):', default: 0.5, type: 'number', step: 'any', minVal: 0.00001 }
                ],
                discrete: false,
                pdf: (x, p) => (x <= 0 || p.sigmaLog <= 0 ? 0 : (1 / (x * p.sigmaLog * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow(Math.log(x) - p.muLog, 2) / (2 * p.sigmaLog * p.sigmaLog))),
                cdf: (x, p) => {
                    if (x <= 0) return 0;
                    if (p.sigmaLog <= 0) return 1; // if sigma_log is 0, it's a spike at exp(muLog)
                    return 0.5 * (1 + math.erf((Math.log(x) - p.muLog) / (p.sigmaLog * Math.sqrt(2))));
                },
                range: (p) => (p.sigmaLog > 0 ? { min: 0.001, max: Math.exp(p.muLog + 4 * p.sigmaLog) } : {min: 0.001, max:1}),
                support: () => ({min: 0, max: Infinity})
            },
            exponential: {
                name: 'Exponential',
                params: [ { id: 'lambda', label: 'Rate (λ):', default: 1, type: 'number', step: 'any', minVal: 0.00001 } ],
                discrete: false,
                pdf: (x, p) => (x < 0 || p.lambda <= 0 ? 0 : p.lambda * Math.exp(-p.lambda * x)),
                cdf: (x, p) => {
                    if (x < 0 || p.lambda <= 0) return 0;
                    return 1 - Math.exp(-p.lambda * x);
                },
                range: (p) => (p.lambda > 0 ? { min: 0, max: 5 / p.lambda } : {min:0, max:5}),
                support: () => ({min: 0, max: Infinity})
            },
            poisson: {
                name: 'Poisson',
                params: [ { id: 'lambda', label: 'Avg Events (λ):', default: 3, type: 'number', step: '1', minVal: 0 } ],
                discrete: true,
                pdf: (k, p) => (k < 0 || p.lambda < 0 || !Number.isInteger(k) ? 0 : (Math.pow(p.lambda, k) * Math.exp(-p.lambda)) / math.factorial(k)),
                cdf: (k, p) => {
                    if (k < 0 || p.lambda < 0) return 0;
                    let sum = 0;
                    for (let i = 0; i <= Math.floor(k); i++) { // Ensure k is integer for summation
                        sum += distributionDefinitions.poisson.pdf(i, p); // Call self PMF
                    }
                    return sum;
                },
                range: (p) => ({ min: Math.max(0, Math.floor(p.lambda - 4 * Math.sqrt(p.lambda))), max: Math.ceil(p.lambda + 4 * Math.sqrt(p.lambda)) +1 }),
                support: () => ({min: 0, max: Infinity})
            },
            triangular: {
                name: 'Triangular',
                params: [
                    { id: 'a', label: 'Min (a):', default: 0, type: 'number', step: 'any' },
                    { id: 'b', label: 'Max (b):', default: 10, type: 'number', step: 'any' },
                    { id: 'c', label: 'Mode (c):', default: 5, type: 'number', step: 'any' }
                ],
                discrete: false,
                pdf: (x, p) => { 
                    const { a, b, c } = p;
                    if (b <= a || c < a || c > b) return 0;
                    if (x < a || x > b) return 0;
                    if (a === c && c === b) return (x === c ? Infinity : 0); 
                    if (c === a) return (x === a ? (b-a === 0 ? Infinity : 2 / (b - a)) : (x > a && x <=b ? 2 * (b - x) / ((b - a) * (b - a)) : 0) );
                    if (c === b) return (x === b ? (b-a === 0 ? Infinity : 2 / (b - a)) : (x >= a && x < b ? 2 * (x - a) / ((b - a) * (b - a)) : 0) );
                    if (x <= c) return (c-a === 0 ? (x === c ? Infinity : 0) : (2 * (x - a)) / ((b - a) * (c - a)));
                    if (x > c) return (b-c === 0 ? (x === c ? Infinity : 0) : (2 * (b - x)) / ((b - a) * (b - c)));
                    return 0;
                },
                cdf: (x, p) => {
                    const { a, b, c } = p;
                    if (b <= a || c < a || c > b) return (x < a ? 0 : 1); // Simplified for invalid params
                    if (x < a) return 0;
                    if (x >= b) return 1;
                    if (a === b) return (x >= a ? 1: 0); // Point mass

                    if (x <= c) {
                        if (c - a === 0) return (x === a ? 0 : 1); // If mode is min, effectively a right triangle starting at a or spike
                        return ((x - a) * (x - a)) / ((b - a) * (c - a));
                    } else { // x > c
                        if (b - c === 0) return (x === b ? 1 : 0); // If mode is max, effectively a left triangle ending at b or spike
                        return 1 - ((b - x) * (b - x)) / ((b - a) * (b - c));
                    }
                },
                range: (p) => ({ min: p.a, max: p.b }),
                support: (p) => ({min: p.a, max: p.b})
            },
            beta: {
                name: 'Beta',
                params: [
                    { id: 'alpha', label: 'Alpha (α):', default: 2, type: 'number', step: 'any', minVal: 0.00001 },
                    { id: 'beta', label: 'Beta (β):', default: 5, type: 'number', step: 'any', minVal: 0.00001 }
                ],
                discrete: false,
                pdf: (x, p) => {
                    const { alpha, beta } = p;
                    if (alpha <= 0 || beta <= 0) return 0;
                    if (x < 0 || x > 1) return 0;
                    if ((x === 0 && alpha < 1) || (x === 1 && beta < 1)) return Infinity;
                    if (x === 0 && alpha === 1) return beta; 
                    if (x === 1 && beta === 1) return alpha; 
                    if ((x === 0 && alpha > 1) || (x === 1 && beta > 1)) return 0;
                    const logGammaAlpha = Math.log(math.gamma(alpha));
                    const logGammaBeta = Math.log(math.gamma(beta));
                    const logGammaAlphaPlusBeta = Math.log(math.gamma(alpha + beta));
                    const logBetaFunc = logGammaAlpha + logGammaBeta - logGammaAlphaPlusBeta;
                    return Math.exp((alpha - 1) * Math.log(x) + (beta - 1) * Math.log(1 - x) - logBetaFunc);
                },
                range: (p) => ({ min: 0, max: 1 }),
                support: () => ({min: 0, max: 1})
            },
            gamma: {
                name: 'Gamma',
                params: [
                    { id: 'alpha', label: 'Shape (α):', default: 2, type: 'number', step: 'any', minVal: 0.00001 },
                    { id: 'betaRate', label: 'Rate (β):', default: 1, type: 'number', step: 'any', minVal: 0.00001 }
                ],
                discrete: false,
                pdf: (x, p) => {
                    const { alpha, betaRate } = p;
                    if (alpha <= 0 || betaRate <= 0) return 0;
                    if (x < 0) return 0;
                    if (x === 0) {
                        if (alpha === 1) return betaRate;
                        if (alpha < 1) return Infinity;
                        return 0;
                    }
                    return (Math.pow(betaRate, alpha) / math.gamma(alpha)) * Math.pow(x, alpha - 1) * Math.exp(-betaRate * x);
                },
                range: (p) => (p.betaRate > 0 ? { min: 0, max: p.alpha / p.betaRate + 5 * Math.sqrt(p.alpha) / p.betaRate } : {min:0, max:5}),
                support: () => ({min: 0, max: Infinity})
            },
            bernoulli: {
                name: 'Bernoulli',
                params: [ { id: 'prob', label: 'Prob of Success (p):', default: 0.5, type: 'number', step: 'any', minVal: 0, maxVal: 1 } ],
                discrete: true,
                pdf: (k, p) => {
                    const rk = Math.round(k); // Handle potential float k from chart
                    if (p.prob < 0 || p.prob > 1) return 0;
                    if (rk === 0) return 1 - p.prob;
                    if (rk === 1) return p.prob;
                    return 0;
                },
                cdf: (k, p) => {
                    if (k < 0) return 0;
                    // k is often float from chart labels, round for discrete logic
                    const rk = Math.round(k);
                    if (rk < 0) return 0;
                    if (rk < 1) return 1 - p.prob; // P(X=0)
                    return 1; // P(X=0) + P(X=1)
                },
                range: (p) => ({ min: -0.5, max: 1.5 }),
                support: () => ({min:0, max:1})
            },
            binomial: {
                name: 'Binomial',
                params: [
                    { id: 'n', label: 'Number of Trials (n):', default: 10, type: 'number', step: '1', minVal: 0 },
                    { id: 'prob', label: 'Prob of Success (p):', default: 0.5, type: 'number', step: 'any', minVal: 0, maxVal: 1 }
                ],
                discrete: true,
                pdf: (k, p) => {
                    const { n, prob } = p;
                    const rk = Math.round(k); // Handle potential float k
                    if (prob < 0 || prob > 1 || n < 0 || !Number.isInteger(n) || rk < 0 || rk > n || !Number.isInteger(rk)) return 0;
                    if (n === 0 && rk === 0) return 1;
                    return math.combinations(n, rk) * Math.pow(prob, rk) * Math.pow(1 - prob, n - rk);
                },
                cdf: (k, p) => {
                    const { n } = p;
                    if (k < 0) return 0;
                    if (k >= n) return 1; // Sum up to n is 1
                    let sum = 0;
                    // k is often float from chart labels, round for discrete logic
                    for (let i = 0; i <= Math.floor(k); i++) {
                        if (i > n) break; // Should not happen if k < n
                        sum += distributionDefinitions.binomial.pdf(i, p); // Call self PMF
                    }
                    return sum;
                },
                range: (p) => ({ min: -0.5, max: p.n + 0.5 }),
                support: (p) => ({min:0, max:p.n})
            }
        };

        // --- DOM Elements ---
        const distNameInput = document.getElementById('distName');
        const distTypeSelect = document.getElementById('distType');
        const paramInputsContainer = document.getElementById('paramInputsContainer');
        const clipMinInput = document.getElementById('clipMin');
        const clipMaxInput = document.getElementById('clipMax');
        const distColorSelect = document.getElementById('distColor');
        const fillLineCheckbox = document.getElementById('fillLine');
        const saveDistButton = document.getElementById('saveDistButton');
        const cancelEditButton = document.getElementById('cancelEditButton');
        const distributionsListDiv = document.getElementById('distributionsList');
        const logScaleXCheckbox = document.getElementById('logScaleX');
        const formTitle = document.getElementById('formTitle');
        const plotPointsInput = document.getElementById('plotPoints');
        const toggleFormButton = document.getElementById('toggleFormButton');
        const toggleButtonText = document.getElementById('toggleButtonText');
        const toggleButtonIcon = document.getElementById('toggleButtonIcon');
        const addEditFormContainer = document.getElementById('addEditFormContainer');

        // --- Form Toggle Function ---
        function toggleFormVisibility(forceShow = null) {
            if (forceShow !== null) {
                isFormVisible = forceShow;
            } else {
                isFormVisible = !isFormVisible;
            }
            
            if (isFormVisible) {
                // Show form with animation
                addEditFormContainer.style.maxHeight = '2000px';
                addEditFormContainer.style.opacity = '1';
                toggleButtonText.textContent = 'Hide Form';
                toggleButtonIcon.classList.add('transform', 'rotate-45');
            } else {
                // Hide form with animation
                addEditFormContainer.style.maxHeight = '0';
                addEditFormContainer.style.opacity = '0';
                toggleButtonText.textContent = 'Add New Distribution';
                toggleButtonIcon.classList.remove('transform', 'rotate-45');
            }
        }

        // --- UI Initialization ---
        function populateDistributionTypes() {
            distTypeSelect.innerHTML = '';
            Object.keys(distributionDefinitions).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = distributionDefinitions[key].name;
                distTypeSelect.appendChild(option);
            });
        }

        function populateColorOptions() {
            distColorSelect.innerHTML = '';
            Object.entries(COLOR_MAP).forEach(([name, hex]) => {
                const option = document.createElement('option');
                option.value = hex;
                option.textContent = name;
                distColorSelect.appendChild(option);
            });
        }

        function updateParameterInputs(selectedDistKey) {
            paramInputsContainer.innerHTML = ''; 
            const distDef = distributionDefinitions[selectedDistKey];
            if (!distDef) return;

            distDef.params.forEach(param => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'flex flex-col';

                const label = document.createElement('label');
                label.htmlFor = `param_${param.id}`;
                label.textContent = param.label;
                label.className = 'text-xs font-medium text-gray-600 mb-0.5';
                groupDiv.appendChild(label);

                const input = document.createElement('input');
                input.type = param.type || 'number';
                input.id = `param_${param.id}`;
                input.name = param.id;
                input.className = 'mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm transition-colors duration-200 ease-in-out hover:border-indigo-400'; 
                input.value = param.default;
                if (param.step) input.step = param.step;
                if (param.minVal !== undefined) input.min = param.minVal;
                if (param.maxVal !== undefined) input.max = param.maxVal;
                groupDiv.appendChild(input);
                paramInputsContainer.appendChild(groupDiv);
            });
        }

        // --- Chart Logic ---
        function initializeChart() {
            const ctx = document.getElementById('distributionsChart').getContext('2d');
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels: [], datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: { type: 'linear', title: { display: true, text: 'X Value' } },
                        y: { title: { display: true, text: 'Density / Probability' }, beginAtZero: true, grace: '5%' }
                    },
                    plugins: {
                        legend: {
                            position: 'top', 
                            align: 'end',
                            labels: { 
                                boxWidth: 10,
                                padding: 6,
                                font: { size: 11 }
                            },
                            title: {
                                display: false
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed.y !== null) label += context.parsed.y.toFixed(5);
                                    return label;
                                }
                            }
                        }
                    }
                }
            });

            chartInstance.options.plugins.afterDraw = (chart) => {
                const chartArea = chart.chartArea;
                if (!chartArea) return;

                chart.data.datasets.forEach((dataset, datasetIndex) => {
                    const meta = chart.getDatasetMeta(datasetIndex);
                    if (!meta.hidden && dataset.data.length > 0) {
                        const dist = distributions[datasetIndex];
                        if (!dist) return;
                        const distDef = distributionDefinitions[dist.type];

                        const drawClipIconAtPoint = (xVal, yVal, color) => {
                            const xAxis = chart.scales.x;
                            const yAxis = chart.scales.y;
                            const xPixel = xAxis.getPixelForValue(xVal);
                            const yPixel = yAxis.getPixelForValue(yVal);

                            if (xPixel >= chartArea.left - FLOAT_COMPARISON_TOLERANCE && 
                                xPixel <= chartArea.right + FLOAT_COMPARISON_TOLERANCE &&
                                yPixel >= chartArea.top - FLOAT_COMPARISON_TOLERANCE && 
                                yPixel <= chartArea.bottom + FLOAT_COMPARISON_TOLERANCE) {
                                const ctx = chart.ctx;
                                ctx.save();
                                ctx.fillStyle = color;
                                ctx.beginPath();
                                ctx.arc(xPixel, yPixel, 3.5, 0, 2 * Math.PI); 
                                ctx.fill();
                                ctx.restore();
                            }
                        };

                        if (dist.clipMin !== null) {
                            let firstPlottedXVal, firstPlottedYVal;
                            const firstValidIndex = dataset.data.findIndex(val => val !== null && 
                                (typeof val === 'number' || (typeof val === 'object' && val.y !== null)));
                            
                            if(firstValidIndex !== -1){
                                if (typeof dataset.data[firstValidIndex] === 'object') {
                                    firstPlottedXVal = dataset.data[firstValidIndex].x;
                                    firstPlottedYVal = dataset.data[firstValidIndex].y;
                                } else {
                                    firstPlottedXVal = chart.data.labels[firstValidIndex];
                                    firstPlottedYVal = dataset.data[firstValidIndex];
                                }

                                if (firstPlottedXVal !== undefined && 
                                    Math.abs(firstPlottedXVal - dist.clipMin) < FLOAT_COMPARISON_TOLERANCE) {
                                    const naturalSupport = distDef.support(dist.params);
                                    if (dist.clipMin > naturalSupport.min + FLOAT_COMPARISON_TOLERANCE) {
                                        drawClipIconAtPoint(firstPlottedXVal, firstPlottedYVal, dataset.borderColor);
                                    }
                                }
                            }
                        }

                        if (dist.clipMax !== null) {
                            let lastPlottedXVal, lastPlottedYVal;
                            for (let i = dataset.data.length - 1; i >= 0; i--) {
                                const point = dataset.data[i];
                                if (point !== null && (typeof point === 'number' || 
                                    (typeof point === 'object' && point.y !== null))) {
                                    if (typeof point === 'object') {
                                        lastPlottedXVal = point.x;
                                        lastPlottedYVal = point.y;
                                    } else {
                                        lastPlottedXVal = chart.data.labels[i];
                                        lastPlottedYVal = point;
                                    }
                                    break;
                                }
                            }

                            if (lastPlottedXVal !== undefined && 
                                Math.abs(lastPlottedXVal - dist.clipMax) < FLOAT_COMPARISON_TOLERANCE) {
                                const naturalSupport = distDef.support(dist.params);
                                if (dist.clipMax < naturalSupport.max - FLOAT_COMPARISON_TOLERANCE) {
                                    drawClipIconAtPoint(lastPlottedXVal, lastPlottedYVal, dataset.borderColor);
                                }
                            }
                        }
                    }
                });
            };
        }
        
        function calculateChartXRange() {
            let xMin = Infinity, xMax = -Infinity;
            let rangeDefined = false;

            if (distributions.length === 0) return { min: -10, max: 20 };

            distributions.forEach(dist => {
                const distDef = distributionDefinitions[dist.type];
                let dRange = distDef.range(dist.params); 

                if (dist.clipMin !== null && isFinite(dist.clipMin)) {
                    dRange.min = Math.max(dRange.min ?? -Infinity, dist.clipMin);
                     xMin = Math.min(xMin, dist.clipMin); 
                     rangeDefined = true;
                }
                if (dist.clipMax !== null && isFinite(dist.clipMax)) {
                    dRange.max = Math.min(dRange.max ?? Infinity, dist.clipMax);
                    xMax = Math.max(xMax, dist.clipMax); 
                    rangeDefined = true;
                }
                
                if (dRange.min !== undefined && isFinite(dRange.min)) {
                    xMin = Math.min(xMin, dRange.min);
                    rangeDefined = true;
                }
                if (dRange.max !== undefined && isFinite(dRange.max)) {
                    xMax = Math.max(xMax, dRange.max);
                    rangeDefined = true;
                }
            });

            if (!rangeDefined) return { min: -10, max: 20 };
            if (xMin === xMax) { xMin -= 1; xMax += 1; }

            const padding = (xMax - xMin) * 0.05 || 1; 
            return { min: xMin - padding, max: xMax + padding };
        }

        function updateChart() {
            if (!chartInstance) return;

            const numPoints = parseInt(plotPointsInput.value) || 300;
            const isLog = logScaleXCheckbox.checked;
            
            const { min: chartRangeMinOriginal, max: chartRangeMaxOriginal } = calculateChartXRange();
            let chartRangeMin = chartRangeMinOriginal;
            let chartRangeMax = chartRangeMaxOriginal;

            if (isLog && chartRangeMin <= 0) chartRangeMin = 0.01; 
            if (isLog && chartRangeMax <= chartRangeMin) chartRangeMax = chartRangeMin * 100;


            chartInstance.options.scales.x.type = isLog ? 'logarithmic' : 'linear';
            chartInstance.options.scales.x.min = chartRangeMin;
            chartInstance.options.scales.x.max = chartRangeMax;
            // Update Y-axis title
            chartInstance.options.scales.y.title.text = 'Density / Probability (tails accumulated at clips)';


            let allPlotXValues = new Set();
            distributions.forEach(d => { 
                if (d.clipMin !== null && d.clipMin >= chartRangeMin && d.clipMin <= chartRangeMax) allPlotXValues.add(d.clipMin);
                if (d.clipMax !== null && d.clipMax >= chartRangeMin && d.clipMax <= chartRangeMax) allPlotXValues.add(d.clipMax);
            });
             if (numPoints > 1) {
                if (isLog) {
                    if (chartRangeMin > 0 && chartRangeMax > chartRangeMin) {
                         for (let i = 0; i < numPoints; i++) {
                            allPlotXValues.add(Math.exp(Math.log(chartRangeMin) + (Math.log(chartRangeMax) - Math.log(chartRangeMin)) * i / (numPoints - 1)));
                        }
                    } else { 
                        for (let i = 0; i < numPoints; i++) allPlotXValues.add(chartRangeMin + (chartRangeMax - chartRangeMin) * i / (numPoints - 1));
                    }
                } else {
                    const step = (chartRangeMax - chartRangeMin) / (numPoints - 1);
                    for (let i = 0; i < numPoints; i++) {
                        allPlotXValues.add(chartRangeMin + i * step);
                    }
                }
            } else if (numPoints === 1) {
                 allPlotXValues.add(chartRangeMin + (chartRangeMax-chartRangeMin)/2);
            }
            
            const sortedUniqueX = Array.from(allPlotXValues).sort((a,b) => a-b);
            chartInstance.data.labels = sortedUniqueX.map(x => parseFloat(x.toPrecision(4)));

            chartInstance.data.datasets = distributions.map((dist, index) => {
                const distDef = distributionDefinitions[dist.type];
                
                const yValues = chartInstance.data.labels.map(x_label => {
                    let x = parseFloat(x_label); 
                    let val = distDef.pdf(x, dist.params); // Base PDF/PMF

                    // Accumulate tails if CDF is available and clipping is active at this point
                    if (distDef.cdf) {
                        if (dist.clipMin !== null && Math.abs(x - dist.clipMin) < FLOAT_COMPARISON_TOLERANCE) {
                            let leftTailMass = 0;
                            if (distDef.discrete) {
                                // P(X < clipMin) = CDF(clipMin - 1)
                                // Ensure clipMin-1 is handled correctly by discrete CDFs (e.g., if clipMin is 0)
                                const arg = dist.clipMin - (distDef.name === "Bernoulli" || distDef.name === "Poisson" || distDef.name === "Binomial" ? 1 : FLOAT_COMPARISON_TOLERANCE); // Small offset for continuous-like check
                                leftTailMass = distDef.cdf(arg, dist.params);

                            } else { // Continuous
                                leftTailMass = distDef.cdf(dist.clipMin, dist.params); // P(X <= clipMin)
                            }
                            if (isFinite(leftTailMass) && leftTailMass > 0) { // only add if there's mass
                                val = (isFinite(val) ? val : 0) + leftTailMass;
                            }
                        }
                        if (dist.clipMax !== null && Math.abs(x - dist.clipMax) < FLOAT_COMPARISON_TOLERANCE) {
                            let rightTailMass = 0;
                            // P(X > clipMax) = 1 - CDF(clipMax)
                            rightTailMass = 1 - distDef.cdf(dist.clipMax, dist.params);
                            if (isFinite(rightTailMass) && rightTailMass > 0) { // only add if there's mass
                                val = (isFinite(val) ? val : 0) + rightTailMass;
                            }
                        }
                    }

                    // Final clipping: points outside the clip range are null
                    if ((dist.clipMin !== null && x < dist.clipMin - FLOAT_COMPARISON_TOLERANCE) ||
                        (dist.clipMax !== null && x > dist.clipMax + FLOAT_COMPARISON_TOLERANCE)) {
                        return null;
                    }
                    return isFinite(val) ? val : null; 
                });

                // Simplified label text for the legend
                let datasetLabelText = dist.customName || `${distDef.name} ${index + 1}`;
                if (distDef.discrete) {
                    return {
                        label: datasetLabelText,
                        data: yValues,
                        borderColor: dist.color,
                        backgroundColor: dist.fill ? `${dist.color}4D` : 'transparent',
                        fill: dist.fill ? 'origin' : false,
                        tension: 0, 
                        pointRadius: distDef.discrete ? 3.5 : 1.5, 
                        pointHitRadius: 10,
                        showLine: !distDef.discrete, 
                        stepped: distDef.discrete ? 'before' : false,
                    };
                }
                return {
                    label: datasetLabelText,
                    data: yValues,
                    borderColor: dist.color,
                    backgroundColor: dist.fill ? `${dist.color}4D` : 'transparent',
                    fill: dist.fill ? 'origin' : false,
                    tension: 0.1,
                    pointRadius: 1.5,
                    pointHitRadius: 10,
                };
            });
            chartInstance.update();
        }

        // --- Distribution Management ---
        function renderDistributionsList() {
            distributionsListDiv.innerHTML = '';
            distributions.forEach((dist, index) => {
                const distDef = distributionDefinitions[dist.type];
                const itemDiv = document.createElement('div');
                itemDiv.className = 'flex items-center justify-between p-4 bg-white rounded-lg shadow hover:shadow-md transition-shadow duration-150 border border-gray-100';

                const infoDiv = document.createElement('div');
                infoDiv.className = 'flex-grow mr-2 overflow-hidden'; 
                const nameToShow = dist.customName || distDef.name;
                const paramString = Object.entries(dist.params).map(([paramId,v]) => {
                    const paramDef = distDef.params.find(p => p.id === paramId);
                    const labelPrefix = paramDef ? paramDef.label.split(':')[0] : paramId;
                    return `${labelPrefix}=${parseFloat(v).toPrecision(3)}`;
                }).join(', ');

                infoDiv.innerHTML = `
                    <span class="font-semibold text-indigo-600 truncate" title="${nameToShow}">${nameToShow}</span>
                    <span class="text-xs text-gray-600 block sm:inline sm:ml-1">(${distDef.name}: ${paramString})</span>
                    <div class="text-xs mt-1 sm:mt-0">
                        <span class="mr-2">Color: <span class="inline-block w-3 h-3 rounded-sm align-middle" style="background-color: ${dist.color};"></span></span>
                        <span class="mr-2">Fill: ${dist.fill ? 'Yes' : 'No'}</span>
                        ${dist.clipMin !== null || dist.clipMax !== null ? 
                          `<span>Clip: [${dist.clipMin ?? 'N/A'}-${dist.clipMax ?? 'N/A'}]</span>` : ''}
                        ${!distDef.cdf ? 
                          '<span class="text-orange-500 ml-2 text-xs italic">(Tail accumulation N/A)</span>' : ''}
                    </div>
                `;

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'flex-shrink-0 flex items-center';
                const editButton = document.createElement('button');
                editButton.title = 'Edit Distribution';
                editButton.className = 'text-blue-500 hover:text-blue-700 mr-2 px-2 py-1 rounded hover:bg-blue-50 transition-colors';
                editButton.innerHTML = '<i class="fas fa-pencil-alt"></i>';
                editButton.onclick = () => {
                    toggleFormVisibility(true); // Force show form when editing
                    loadDistributionForEdit(index);
                };
                actionsDiv.appendChild(editButton);

                const deleteButton = document.createElement('button');
                deleteButton.title = 'Delete Distribution';
                deleteButton.className = 'text-red-500 hover:text-red-700 px-2 py-1 rounded hover:bg-red-50 transition-colors';
                deleteButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
                deleteButton.onclick = () => deleteDistribution(index);
                actionsDiv.appendChild(deleteButton);

                itemDiv.appendChild(infoDiv);
                itemDiv.appendChild(actionsDiv);
                distributionsListDiv.appendChild(itemDiv);
            });
            if (distributions.length === 0) {
                distributionsListDiv.innerHTML = `
                    <div class="text-center text-gray-500 italic py-6 bg-white rounded-lg shadow">
                        <i class="fas fa-chart-area text-gray-300 text-4xl mb-2"></i>
                        <p>No distributions added yet. Add one below to get started!</p>
                    </div>`;
            }
        }

        function resetForm() {
            distNameInput.value = '';
            distTypeSelect.value = Object.keys(distributionDefinitions)[0];
            updateParameterInputs(distTypeSelect.value); 
            clipMinInput.value = '';
            clipMaxInput.value = '';
            distColorSelect.value = Object.values(COLOR_MAP)[0];
            fillLineCheckbox.checked = false;
            currentEditIndex = -1;
            saveDistButton.innerHTML = '<i class="fas fa-plus mr-2"></i> Add';
            saveDistButton.title = 'Add Distribution';
            saveDistButton.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'focus:ring-blue-500');
            saveDistButton.classList.add('bg-green-600', 'hover:bg-green-700', 'focus:ring-green-500');
            cancelEditButton.classList.add('hidden');
            formTitle.textContent = 'Add New Distribution';
            
            // Hide form after reset if not editing
            if (currentEditIndex === -1) {
                toggleFormVisibility(false);
            }
        }

        function loadDistributionForEdit(index) {
            const dist = distributions[index];
            currentEditIndex = index;

            distNameInput.value = dist.customName || '';
            distTypeSelect.value = dist.type;
            updateParameterInputs(dist.type); 

            const distDef = distributionDefinitions[dist.type];
            distDef.params.forEach(param => {
                document.getElementById(`param_${param.id}`).value = dist.params[param.id];
            });

            clipMinInput.value = dist.clipMin !== null ? dist.clipMin : '';
            clipMaxInput.value = dist.clipMax !== null ? dist.clipMax : '';
            distColorSelect.value = dist.color;
            fillLineCheckbox.checked = dist.fill;

            saveDistButton.innerHTML = '<i class="fas fa-save mr-2"></i> Save';
            saveDistButton.title = 'Save Changes';
            saveDistButton.classList.remove('bg-green-600', 'hover:bg-green-700', 'focus:ring-green-500');
            saveDistButton.classList.add('bg-blue-600', 'hover:bg-blue-700', 'focus:ring-blue-500');
            cancelEditButton.classList.remove('hidden');
            formTitle.textContent = `Edit: ${dist.customName || distDef.name}`;
            addEditFormContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function saveDistribution() {
            const type = distTypeSelect.value;
            const distDef = distributionDefinitions[type];
            const params = {};
            let valid = true;

            distDef.params.forEach(param => {
                const inputElement = document.getElementById(`param_${param.id}`);
                let valueStr = inputElement.value.trim();
                let value;

                if (valueStr === '') { 
                     alert(`Parameter ${param.label} cannot be empty.`);
                     inputElement.focus(); valid = false; return;
                }

                if (param.type === 'number' || !param.type) {
                    value = parseFloat(valueStr);
                    if (inputElement.step === '1') value = parseInt(valueStr); 
                } else {
                    value = valueStr;
                }
                
                if ((param.type === 'number' || !param.type) && isNaN(value)) {
                    alert(`Invalid number for ${param.label}.`);
                    inputElement.focus(); valid = false; return;
                }

                if (param.minVal !== undefined && value < param.minVal) {
                     alert(`${param.label} must be at least ${param.minVal}.`);
                     inputElement.focus(); valid = false; return;
                }
                if (param.maxVal !== undefined && value > param.maxVal) {
                     alert(`${param.label} must be at most ${param.maxVal}.`);
                     inputElement.focus(); valid = false; return;
                }
                params[param.id] = value;
            });

            if (!valid) return;
            
            if (type === 'uniform' && params.b <= params.a) {
                alert('For Uniform distribution, Max (b) must be greater than Min (a).'); valid = false;
            }
            if (type === 'triangular') {
                if (params.b <= params.a) { alert('Triangular: Max (b) must be > Min (a).'); valid = false; }
                else if (params.c < params.a || params.c > params.b) { 
                    alert('Triangular: Mode (c) must be between Min (a) and Max (b).'); valid = false; 
                }
            }
            if (!valid) return;

            const newDistribution = {
                customName: distNameInput.value.trim() || '',
                type: type,
                params: params,
                color: distColorSelect.value,
                fill: fillLineCheckbox.checked,
                clipMin: clipMinInput.value !== '' ? parseFloat(clipMinInput.value) : null,
                clipMax: clipMaxInput.value !== '' ? parseFloat(clipMaxInput.value) : null,
            };
            if (newDistribution.clipMin !== null && newDistribution.clipMax !== null && 
                newDistribution.clipMin >= newDistribution.clipMax) {
                alert('Clip Min must be less than Clip Max.');
                clipMinInput.focus();
                return;
            }

            if (currentEditIndex === -1) { 
                distributions.push(newDistribution);
            } else { 
                distributions[currentEditIndex] = newDistribution;
            }

            renderDistributionsList();
            updateChart();
            resetForm();
        }

        function deleteDistribution(index) {
            if (confirm('Are you sure you want to delete this distribution?')) {
                distributions.splice(index, 1);
                if (currentEditIndex === index) resetForm();
                else if (currentEditIndex > index) currentEditIndex--;
                renderDistributionsList();
                updateChart();
            }
        }

        // --- Event Listeners ---
        distTypeSelect.addEventListener('change', (e) => updateParameterInputs(e.target.value));
        saveDistButton.addEventListener('click', saveDistribution);
        cancelEditButton.addEventListener('click', resetForm);
        logScaleXCheckbox.addEventListener('change', updateChart);
        plotPointsInput.addEventListener('change', updateChart);
        toggleFormButton.addEventListener('click', toggleFormVisibility);
        
        // --- Initial Setup ---
        window.onload = () => {
            populateDistributionTypes();
            populateColorOptions();
            updateParameterInputs(distTypeSelect.value); 
            initializeChart();
            renderDistributionsList(); 
            updateChart(); 
            // Start with the form hidden
            toggleFormVisibility(false);
        };
    </script>
</body>
</html>
